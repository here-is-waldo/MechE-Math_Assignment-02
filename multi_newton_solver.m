%Your Implementation of Newton's method
%INPUTS:
%fun: the mathematical function for which we want to compute the root
% note that the output of fun may include the derivative
% i.e. [fval,dfdx] = fun(x)
% or not, i.e. fval = fun(x)
%x_guess the initial guess for Newton's method
%solver_params: a MATLAB struct containing solver settings
% solver_params.dxtol: terminate early if |x_{i+1}-x_{i}|<dxtol
% solver_params.ftol: terminate early if |f(x_i)|<ftol
% solver_params.dxmax: terminate early if |x_{i+1}-x_{i}|>dxmax
% (meaning that jacobian is probably singular, which is bad)
% solver_params.numerical_diff: boolean (0 or 1)
% 1-> numerically differentiate, 0-> use analytical derivative
%should use numerical differentation to compute the Jacobian or
%use a Jacobian generated by fun. No input assumes numerical by default
% true->fun is assumed to return [fval,J]
% false->fun is assumed to only return fval
%OUTPUTS:
%x: the estimate of the root computed by the function
% exit_flag: an integer indicating whether or not the solver succeeded
function [x, exit_flag] = multi_newton_solver(fun,x_guess,solver_params)
    %unpack values from struct (if fields in struct have been set)
    dxtol = 1e-14;
    if isfield(solver_params,'dxtol')
        dxtol = solver_params.dxtol;
    end
    ftol = 1e-14;
    if isfield(solver_params,'ftol')
        ftol = solver_params.ftol;
    end
    dxmax = 1e8;
    if isfield(solver_params,'dxmax')
        dxmax = solver_params.dxmax;
    end
    numerical_diff = 1;
    if isfield(solver_params,'numerical_diff')
        numerical_diff = solver_params.numerical_diff;
    end

    f = [];
    if numerical_diff == 0
        f = fun(1);
        jacobian = fun(2);
    else
        f = fun;
    end

    exit_flag = 0; % tracks whether or not code works, 0 = failed, 1 = succeeded 
    
    max_iter = 300;
    Xn = x_guess;
    for i = 1:max_iter

        % set values and Jacobian
        if numerical_diff == 0 % analytical derivation
            fn = f(Xn);
            Jn = jacobian(Xn);
        else
            fn = f(Xn);
            Jn = approximate_jacobian(f, Xn);
        end

        if det(Jn * Jn') == 0 % matrix inversion safeguard
            break
        end
        deltaX = Jn \ fn;
        Xn = Xn - deltaX;

        % early exit conditions
        if norm(deltaX) < dxtol
            break
        end

        if norm(f(Xn)) < ftol
            exit_flag = 1;  % succeeded within acceptable parameters
            break
        end
    end
    x = Xn;

    % check if succeeded
    if (f(x) < ftol)
        exit_flag = 1;
    end
end